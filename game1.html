<!DOCTYPE html>
<html>
<head>
<title>Memory Grid Game</title>
<style>
    body {
        background: #0e0e0e;
        color: white;
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    h1 { margin-top: 20px; font-size: 28px; }
    #grid {
        display: grid;
        grid-template-columns: repeat(7, 50px);
        grid-template-rows: repeat(7, 50px);
        gap: 5px;
        margin-top: 20px;
    }
    .cell {
        width: 50px;
        height: 50px;
        background: #444;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 22px;
        border-radius: 6px;
        cursor: pointer;
    }
    .safe { background: #2ecc71 !important; }
    .wall { background: #e74c3c !important; }
    .start { background: #3498db !important; }
    .end { background: #f1c40f !important; color: black; }
</style>
</head>
<body>

<h1>Memory Grid Game</h1>

<div id="stats">
    ‚è± Time: <span id="timer">0</span>s  
    | üîÑ Resets: <span id="resets">0</span>  
    | ü¶∂ Moves: <span id="moves">0</span>
</div>

<div id="grid"></div>

<button onclick="restartGame()">Restart Game</button>

<script>
let gridSize = 7;
let start = { r: 0, c: 0 };
let end = { r: 6, c: 6 };
let path = [];
let revealed = [];
let resets = 0;
let moves = 0;
let timer = 0;
let timerInterval = null;

// Initialize revealed grid state
function initRevealed() {
    revealed = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
    revealed[start.r][start.c] = true; // Start always visible
    revealed[end.r][end.c] = false; // End not revealed until clicked
}

// Generate a random safe path
function generatePath() {
    let r = start.r;
    let c = start.c;
    let p = [{ r, c }];

    while (r !== end.r || c !== end.c) {
        let choices = [];
        if (r < end.r) choices.push("down");
        if (c < end.c) choices.push("right");
        if (r > end.r) choices.push("up");
        if (c > end.c) choices.push("left");

        let move = choices[Math.floor(Math.random() * choices.length)];

        if (move === "down") r++;
        if (move === "right") c++;
        if (move === "up") r--;
        if (move === "left") c--;

        p.push({ r, c });
    }
    return p;
}

// Create the grid with preserved SAFE tiles
function createGrid() {
    const grid = document.getElementById("grid");
    grid.innerHTML = "";

    for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
            let div = document.createElement("div");
            div.classList.add("cell");

            if (r === start.r && c === start.c) {
                div.textContent = "S";
                div.classList.add("start");
            } 
            else if (r === end.r && c === end.c) {
                div.textContent = "E";
                div.classList.add("end");
            }
            else if (revealed[r][c]) {
                div.textContent = "";
                div.classList.add("safe");
            }
            else {
                div.textContent = "?";
            }

            div.onclick = () => cellClicked(r, c, div);
            grid.appendChild(div);
        }
    }
}

// Handle clicking tiles
function cellClicked(r, c, cell) {
    moves++;
    document.getElementById("moves").textContent = moves;

    if (r === start.r && c === start.c) return;

    let isSafe = path.some(p => p.r === r && p.c === c);

    if (!isSafe) {
        // Wrong tile ‚Üí temporary red highlight
        cell.classList.add("wall");
        setTimeout(resetAfterMistake, 500);
        return;
    }

    // Mark safe tile as permanently revealed
    revealed[r][c] = true;

    cell.classList.add("safe");
    cell.textContent = "";

    if (r === end.r && c === end.c) {
        clearInterval(timerInterval);
        alert("üéâ YOU WIN!\nTime: " + timer + "s\nResets: " + resets + "\nMoves: " + moves);
    }
}

// Reset after hitting a wall
function resetAfterMistake() {
    resets++;
    document.getElementById("resets").textContent = resets;

    moves = 0;
    document.getElementById("moves").textContent = moves;

    // DO NOT ERASE SAFE TILES
    createGrid();
}

function restartGame() {
    resets = 0;
    moves = 0;
    timer = 0;

    document.getElementById("resets").textContent = resets;
    document.getElementById("moves").textContent = moves;
    document.getElementById("timer").textContent = timer;

    clearInterval(timerInterval);
    startTimer();

    initRevealed();
    path = generatePath();
    createGrid();
}

// Timer
function startTimer() {
    timerInterval = setInterval(() => {
        timer++;
        document.getElementById("timer").textContent = timer;
    }, 1000);
}

// Initialize game
initRevealed();
path = generatePath();
createGrid();
startTimer();
</script>


</body>
</html>
