<!DOCTYPE html>
<html>
<head>
<title>Memory Grid Game</title>
<style>
    :root {
        --cell-size: 50px;
        --grid-gap: 5px;
    }

    body {
        background: #0e0e0e;
        color: white;
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 0 24px 40px;
    }
    h1 { margin-top: 20px; font-size: 28px; }

    #controls {
        margin-top: 10px;
    }
    #controls button {
        margin: 0 5px;
        padding: 8px 14px;
        border-radius: 6px;
        border: none;
        cursor: pointer;
        font-size: 14px;
    }
    #controls button.active {
        outline: 2px solid #f1c40f;
    }

    #levelMessage {
        margin-top: 10px;
        font-size: 16px;
        min-height: 24px;
    }

    #playArea {
        margin-top: 15px;
        width: 100%;
        max-width: 900px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        align-items: center;
    }
    #instructions {
        font-size: 15px;
        max-width: 360px;
        line-height: 1.4;
        text-align: left;
        margin: 0 auto;
        width: 100%;
    }
    body.game-live #instructions {
        flex: 1;
    }
    #gridWrapper {
        display: flex;
        justify-content: center;
        width: 100%;
    }
    #instructions ul {
        margin: 6px 0 0 16px;
        padding: 0;
    }
    #instructions li {
        margin-bottom: 4px;
    }

    #grid {
        display: grid;
        grid-template-columns: repeat(7, var(--cell-size));
        grid-template-rows: repeat(7, var(--cell-size));
        gap: var(--grid-gap);
        margin: 20px auto 0;
        width: 100%;
        max-width: 420px;
    }
    .cell {
        width: var(--cell-size);
        height: var(--cell-size);
        background: #444;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 22px;
        border-radius: 6px;
        cursor: pointer;
        user-select: none;
    }
    .safe { background: #2ecc71 !important; }
    .wall { background: #e74c3c !important; }
    .start { background: #3498db !important; }
    .door { background: #f1c40f !important; color: black; }
    .key { background: #9b59b6 !important; }

    #stats {
        margin-top: 15px;
        font-size: 18px;
    }

    #restartBtn {
        margin-top: 15px;
        padding: 10px 20px;
        font-size: 16px;
        border-radius: 8px;
        cursor: pointer;
        border: none;
    }

    @media (max-width: 540px) {
        body {
            padding: 0 16px 32px;
        }
        h1 {
            font-size: 24px;
            text-align: center;
        }
        #stats {
            font-size: 16px;
            text-align: center;
            line-height: 1.4;
        }
        #instructions {
            max-width: 100%;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        #controls button {
            margin-top: 6px;
        }
    }

    @media (min-width: 768px) {
        body.game-live #playArea {
            flex-direction: row;
            align-items: flex-start;
        }
        body.game-live #instructions {
            text-align: left;
            margin: 0;
        }
        body.game-live #gridWrapper {
            flex: 1;
        }
    }
</style>
</head>
<body>

<h1>Memory Grid Game</h1>

<div id="controls">
    <button id="startBtn" onclick="startGame()">Start Game</button>
    <button id="easyBtn" onclick="setDifficulty('easy')">Easy</button>
    <button id="hardBtn" onclick="setDifficulty('hard')">Hard (Hiring Style)</button>
    <button id="harderBtn" onclick="makeGridHarder()">Next Level</button>
</div>

<div id="levelMessage">Press Start Game to begin.</div>

<div id="stats">
    üî¢ Level: <span id="levelDisplay">1 / 5</span>  
    | ‚è± Time: <span id="timer">0</span>s  
    | üîÑ Resets: <span id="resets">0</span>  
    | ü¶∂ Moves: <span id="moves">0</span>  
    | üîë Key: <span id="keyStatus">No</span>
</div>

<div id="playArea">
    <div id="instructions">
        <strong>How to play:</strong>
        <ul>
            <li>Hit <strong>Start Game</strong> when you're ready; the timer begins once the board appears.</li>
            <li>Tap tiles to trace the hidden safe path from <strong>S</strong> to the door.</li>
            <li>The door stays locked until you uncover the hidden <strong>key</strong>.</li>
            <li>A wrong tile resets the board (hard mode hides your progress).</li>
            <li>Use Restart to start over or Next Level to skip ahead‚Äîonly wins count toward finishing all five levels.</li>
        </ul>
    </div>

    <div id="gridWrapper">
        <div id="grid"></div>
    </div>
</div>

<button id="restartBtn" onclick="restartGame()">Restart Game</button>

<script>
const LEVELS = [5, 6, 7, 8, 9];
const TOTAL_LEVELS = LEVELS.length;
let currentLevelIndex = 0;
let gridSize = LEVELS[currentLevelIndex];
let start = { r: 0, c: 0 };
let end = { r: gridSize - 1, c: gridSize - 1 };
let path = [];
let revealed = [];
let resets = 0;
let moves = 0;
let timer = 0;
let timerInterval = null;
let difficulty = "hard"; // default to harder, hiring-style
const MIN_START_END_DISTANCE = 4; // keep S and E apart for better gameplay
const GRID_GAP = 5;
let keyCell = null;
let hasKey = false;
let pendingResetTimeout = null;
let levelsWon = 0;
let gameActive = false;

// Update difficulty UI
function updateDifficultyButtons() {
    document.getElementById("easyBtn").classList.toggle("active", difficulty === "easy");
    document.getElementById("hardBtn").classList.toggle("active", difficulty === "hard");
}

// Called from buttons
function setDifficulty(level) {
    if (difficulty === level) return;
    difficulty = level;
    updateDifficultyButtons();
    if (!gameActive) {
        showMessage(`${level === "easy" ? "Easy" : "Hard"} mode selected. Press Start Game to begin.`);
        return;
    }
    initializeGameState();
}

// Initialize revealed grid
function initRevealed() {
    revealed = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
    revealed[start.r][start.c] = true; // Start always visible
    // End will be shown as E but not marked safe until clicked correctly
}

function updateLevelDisplay() {
    document.getElementById("levelDisplay").textContent = `${currentLevelIndex + 1} / ${TOTAL_LEVELS}`;
}

function updateKeyStatus() {
    document.getElementById("keyStatus").textContent = hasKey ? "Yes" : "No";
}

function showMessage(msg) {
    document.getElementById("levelMessage").textContent = msg;
}

function updateLayoutState() {
    document.body.classList.toggle("game-live", gameActive);
}

function updateResponsiveCellSize() {
    const gridElement = document.getElementById("grid");
    if (!gridElement) return;
    const viewportWidth = window.innerWidth || 420;
    const maxWidth = Math.min(viewportWidth - 40, 420);
    const safeWidth = Math.max(180, maxWidth);
    const totalGap = (gridSize - 1) * GRID_GAP;
    const cellSize = Math.max(32, Math.floor((safeWidth - totalGap) / gridSize));
    const gridWidth = cellSize * gridSize + totalGap;
    document.documentElement.style.setProperty("--cell-size", `${cellSize}px`);
    document.documentElement.style.setProperty("--grid-gap", `${GRID_GAP}px`);
    gridElement.style.width = `${gridWidth}px`;
}

// Generate a random safe path
function generatePath() {
    let r = start.r;
    let c = start.c;
    let p = [{ r, c }];

    while (r !== end.r || c !== end.c) {
        let choices = [];
        if (r < end.r) choices.push("down");
        if (c < end.c) choices.push("right");
        if (r > end.r) choices.push("up");
        if (c > end.c) choices.push("left");

        let move = choices[Math.floor(Math.random() * choices.length)];

        if (move === "down") r++;
        if (move === "right") c++;
        if (move === "up") r--;
        if (move === "left") c--;

        p.push({ r, c });
    }
    return p;
}

function placeKey() {
    if (path.length <= 2) {
        keyCell = null;
        return;
    }
    const keyIndex = Math.floor(Math.random() * (path.length - 2)) + 1; // exclude start/end
    keyCell = path[keyIndex];
}

// Build the grid UI
function createGrid() {
    const grid = document.getElementById("grid");
    updateResponsiveCellSize();
    if (!gameActive) {
        grid.innerHTML = "";
        return;
    }
    grid.innerHTML = "";
    grid.style.gridTemplateColumns = `repeat(${gridSize}, var(--cell-size))`;
    grid.style.gridTemplateRows = `repeat(${gridSize}, var(--cell-size))`;

    for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
            let div = document.createElement("div");
            div.classList.add("cell");

            if (r === start.r && c === start.c) {
                div.textContent = "S";
                div.classList.add("start");
            } 
            else if (r === end.r && c === end.c) {
                div.textContent = "D";
                div.classList.add("door");
            }
            else if (keyCell && r === keyCell.r && c === keyCell.c) {
                if (revealed[r][c]) {
                    div.classList.add("key");
                    div.textContent = "K";
                } else {
                    div.textContent = "?";
                }
            }
            else if (revealed[r][c]) {
                // EASY mode: keep showing discovered safes
                if (difficulty === "easy") {
                    div.classList.add("safe");
                    div.textContent = "";
                } else {
                    // HARD mode: do not show previous safes, keep them hidden
                    div.textContent = "?";
                }
            } 
            else {
                div.textContent = "?";
            }

            div.onclick = () => cellClicked(r, c, div);
            grid.appendChild(div);
        }
    }
}

// Handle clicks
function cellClicked(r, c, cell) {
    if (!gameActive) {
        showMessage("Press Start Game to begin!");
        return;
    }
    moves++;
    document.getElementById("moves").textContent = moves;

    if (r === start.r && c === start.c) return;

    let isSafe = path.some(p => p.r === r && p.c === c);

    if (!isSafe) {
        cell.classList.add("wall");
        scheduleResetAfterMistake();
        return;
    }

    // Correct (safe) tile
    revealed[r][c] = true;

    // Always show it for the current attempt
    cell.classList.add("safe");
    cell.textContent = "";

    if (keyCell && r === keyCell.r && c === keyCell.c && !hasKey) {
        hasKey = true;
        updateKeyStatus();
        showMessage("Key collected! Find the door.");
        createGrid();
        return;
    }

    if (r === end.r && c === end.c) {
        if (!hasKey) {
            showMessage("The door is locked! Grab the key first.");
            createGrid();
            return;
        }
        stopTimer();
        levelComplete();
    }
}

// When user hits a wall
function resetAfterMistake() {
    if (!gameActive) return;
    resets++;
    document.getElementById("resets").textContent = resets;
    moves = 0;
    document.getElementById("moves").textContent = moves;

    hasKey = false;
    updateKeyStatus();

    if (difficulty === "easy") {
        // Keep known safes visible
        createGrid();
    } else {
        // HARD: forget all discovered safes visually & logically
        initRevealed();
        createGrid();
    }
    showMessage("Ouch! Try again from the start.");
}

function scheduleResetAfterMistake() {
    cancelPendingReset();
    pendingResetTimeout = setTimeout(() => {
        pendingResetTimeout = null;
        resetAfterMistake();
    }, 400);
}

function cancelPendingReset() {
    if (pendingResetTimeout !== null) {
        clearTimeout(pendingResetTimeout);
        pendingResetTimeout = null;
    }
}

// Restart everything
function initializeGameState() {
    if (!gameActive) return;
    cancelPendingReset();
    const levelSize = LEVELS[currentLevelIndex];
    gridSize = levelSize;
    resets = 0;
    moves = 0;
    timer = 0;
    hasKey = false;
    document.getElementById("resets").textContent = resets;
    document.getElementById("moves").textContent = moves;
    document.getElementById("timer").textContent = timer;
    updateKeyStatus();
    updateLevelDisplay();
    showMessage("Collect the key before heading to the door.");

    startTimer();

    randomizeStartEnd();

    initRevealed();
    path = generatePath();
    placeKey();
    createGrid();
}

function restartGame(forceStart = false) {
    if (!gameActive && !forceStart) {
        showMessage("Press Start Game to begin!");
        return;
    }
    if (forceStart) {
        gameActive = true;
    }
    currentLevelIndex = 0;
    levelsWon = 0;
    initializeGameState();
    updateLayoutState();
}

function startGame() {
    restartGame(true);
}

function makeGridHarder() {
    if (!gameActive) {
        showMessage("Start the game before skipping levels.");
        return;
    }
    if (currentLevelIndex < TOTAL_LEVELS - 1) {
        currentLevelIndex++;
        initializeGameState();
    } else {
        showMessage("You're already on the final level!");
    }
}

// Timer
function startTimer() {
    stopTimer();
    timerInterval = setInterval(() => {
        timer++;
        document.getElementById("timer").textContent = timer;
    }, 1000);
}

function stopTimer() {
    if (timerInterval !== null) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
}

function randomCell() {
    return {
        r: Math.floor(Math.random() * gridSize),
        c: Math.floor(Math.random() * gridSize)
    };
}

function distanceBetween(a, b) {
    const dr = a.r - b.r;
    const dc = a.c - b.c;
    return Math.hypot(dr, dc);
}

function randomizeStartEnd() {
    // Generate unique random positions with minimum distance
    start = randomCell();

    do {
        end = randomCell();
    } while (
        (start.r === end.r && start.c === end.c) ||
        distanceBetween(start, end) < MIN_START_END_DISTANCE
    );
}   

function levelComplete() {
    const levelNumber = currentLevelIndex + 1;
    levelsWon = Math.min(levelsWon + 1, TOTAL_LEVELS);
    alert(`üéâ Level ${levelNumber} cleared!\nTime: ${timer}s\nResets: ${resets}\nMoves: ${moves}\nCompleted: ${levelsWon}/${TOTAL_LEVELS}`);

    if (levelsWon >= TOTAL_LEVELS) {
        alert("üèÜ All five levels complete! Restarting from level 1.");
        restartGame();
        return;
    }

    if (currentLevelIndex < TOTAL_LEVELS - 1) {
        currentLevelIndex++;
        initializeGameState();
    } else {
        const remaining = TOTAL_LEVELS - levelsWon;
        alert(`You cleared the final stage but still need ${remaining} more level${remaining === 1 ? "" : "s"} to finish all five. Restarting so you can complete them.`);
        restartGame();
    }
}

// Init on load
updateDifficultyButtons();
updateResponsiveCellSize();
window.addEventListener("resize", updateResponsiveCellSize);
updateLayoutState();
showMessage("Press Start Game to begin.");

</script>

</body>
</html>
