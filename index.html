<!DOCTYPE html>
<html>
<head>
<title>Memory Grid Game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
    :root {
        --cell-size: 50px;
        --grid-gap: 5px;
    }

    body {
        background: #0e0e0e;
        color: white;
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 0 24px 40px;
        min-height: 100vh;
        margin: 0;
    }
    h1 { margin-top: 20px; font-size: 32px; text-align: center; }

    #controls {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 8px;
        width: 100%;
        max-width: 640px;
    }
    #controls button {
        flex: 0 1 auto;
        min-height: 44px;
        margin: 0;
        padding: 10px 18px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        font-size: 16px;
    }
    #controls button.active {
        outline: 2px solid #f1c40f;
    }
body:not(.game-live) #controls button:not(#startBtn) {
    opacity: 0.4;
    pointer-events: none;
}
.compact-ui h1 {
    font-size: 26px;
}

    #levelMessage {
        margin-top: 14px;
        font-size: 18px;
        min-height: 24px;
        text-align: center;
        width: 100%;
        max-width: 640px;
        margin-left: auto;
        margin-right: auto;
    }

    #stats {
        margin-top: 15px;
        font-size: 20px;
        text-align: center;
        line-height: 1.4;
    }

    #playArea {
        margin-top: 25px;
        width: 100%;
        max-width: 1000px;
        display: flex;
        flex-direction: column;
        gap: 24px;
        align-items: center;
        padding: 0 10px;
    }
    #instructions {
        font-size: 18px;
        max-width: 460px;
        line-height: 1.6;
        text-align: left;
        margin: 0 auto;
        width: 100%;
        background: rgba(255,255,255,0.05);
        padding: 12px 18px;
        border-radius: 12px;
    }
    #instructionsToggle {
        width: 100%;
        background: transparent;
        color: inherit;
        border: 1px solid rgba(255,255,255,0.25);
        border-radius: 10px;
        padding: 10px 14px;
        font-size: 16px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: pointer;
    }
    #instructions .chevron {
        display: inline-block;
        width: 0;
        height: 0;
        border-left: 6px solid transparent;
        border-right: 6px solid transparent;
        border-top: 8px solid #fff;
        transition: transform 0.2s ease;
    }
    #instructions .instructions-content {
        overflow: hidden;
        max-height: 1000px;
        transition: max-height 0.3s ease, opacity 0.3s ease, margin-top 0.3s ease;
        margin-top: 10px;
    }
    #instructions.collapsed .instructions-content {
        max-height: 0;
        opacity: 0;
        margin-top: 0;
        pointer-events: none;
    }
    #instructions.collapsed .chevron {
        transform: rotate(-90deg);
    }
    body.game-live #instructions {
        flex: 1;
    }
    #gridWrapper {
        display: none;
        justify-content: center;
        width: 100%;
    }
    body.game-live #gridWrapper {
        display: flex;
        justify-content: center;
        width: 100%;
    }
    #instructions ul {
        margin: 6px 0 0 16px;
        padding: 0;
    }
    #instructions li {
        margin-bottom: 4px;
    }

    #grid {
        display: grid;
        grid-template-columns: repeat(7, var(--cell-size));
        grid-template-rows: repeat(7, var(--cell-size));
        gap: var(--grid-gap);
        margin: 20px auto 0;
        width: 100%;
        max-width: 420px;
    }
    .cell {
        width: var(--cell-size);
        height: var(--cell-size);
        background: #444;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 22px;
        border-radius: 6px;
        cursor: pointer;
        user-select: none;
    }
    .safe { background: #2ecc71 !important; }
    .wall { background: #e74c3c !important; }
    .start { background: #3498db !important; }
    .door { background: #f1c40f !important; color: black; }
    .key { background: #9b59b6 !important; }

    #stats {
        margin-top: 15px;
        font-size: 18px;
    }

    #restartBtn {
        margin-top: 15px;
        padding: 12px 24px;
        font-size: 18px;
        border-radius: 10px;
        cursor: pointer;
        border: none;
        background: #27ae60;
        color: white;
        transition: background 0.2s ease;
        display: none;
    }
    body.game-live #restartBtn {
        display: inline-block;
    }
    #restartBtn:hover {
        background: #1e874b;
    }
    #doorOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 20px;
    }
    #doorOverlay.active {
        display: flex;
    }
    #doorOverlay .door-panel {
        background: #1f1f1f;
        border-radius: 12px;
        padding: 20px;
        text-align: center;
        max-width: 320px;
        width: 100%;
        box-shadow: 0 10px 30px rgba(0,0,0,0.4);
    }
    #doorOverlay .door-panel p {
        margin: 0 0 16px 0;
        font-size: 18px;
        line-height: 1.5;
    }
    #doorOverlay .door-panel button {
        padding: 10px 16px;
        border: none;
        border-radius: 8px;
        background: #f1c40f;
        color: #000;
        cursor: pointer;
        font-size: 15px;
        font-weight: bold;
    }
#messageOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.78);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 999;
        padding: 16px;
    }
#messageOverlay.active {
        display: flex;
    }
#messageOverlay .message-panel {
    background: #1f1f1f;
    border: 1px solid rgba(241, 196, 15, 0.4);
    border-radius: 14px;
    padding: 24px;
        max-width: 420px;
        width: 100%;
        text-align: center;
        box-shadow: 0 12px 32px rgba(0,0,0,0.45);
    }
#messageOverlay .message-panel p {
    margin: 0 0 18px 0;
    font-size: 18px;
    line-height: 1.5;
}
#messageOverlay .message-panel h3 {
    margin-top: 0;
    margin-bottom: 16px;
    font-size: 20px;
}
#messageOverlay .stats-lines p {
    margin: 6px 0;
    font-size: 16px;
}
#messageOverlay .message-panel button {
    width: 100%;
        padding: 10px 14px;
        border: none;
        border-radius: 8px;
        background: #f1c40f;
        color: #000;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
    }
    #recruiterOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 20px;
        z-index: 999;
    }
    #recruiterOverlay.active {
        display: flex;
    }
    #recruiterPanel {
        background: #1c1c1c;
        border-radius: 12px;
        padding: 20px 24px;
        max-width: 520px;
        width: 100%;
        box-shadow: 0 10px 25px rgba(0,0,0,0.4);
        position: relative;
    }
    #recruiterPanel h2 {
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 20px;
        text-align: left;
    }
    #recruiterTags {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 12px;
    }
    .recruiter-tag {
        background: #2c3e50;
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.04em;
    }
    #recruiterSummary {
        margin: 0;
        padding-left: 18px;
        line-height: 1.4;
    }
    #closeRecruiterBtn {
        margin-top: 16px;
        width: 100%;
        padding: 10px 14px;
        border: none;
        border-radius: 8px;
        background: #3498db;
        color: white;
        cursor: pointer;
        font-size: 15px;
    }
    #closeRecruiterBtn:hover {
        background: #2980b9;
    }
    #recruiterPanel .close-icon {
        position: absolute;
        top: 10px;
        right: 12px;
        background: none;
        border: none;
        font-size: 20px;
        color: #fff;
        cursor: pointer;
    }

    @media (max-width: 600px) {
        body {
            padding: 0 12px 20px;
            overflow-x: hidden;
        }
        h1 {
            font-size: 26px;
        }
        #controls {
            gap: 6px;
        }
        #controls button {
            flex: 1 1 48%;
            max-width: 100%;
            font-size: 15px;
            padding: 8px 12px;
        }
        #levelMessage {
            font-size: 15px;
        }
        #stats {
            font-size: 16px;
            line-height: 1.5;
        }
        #instructions {
            font-size: 15px;
            padding: 10px 14px;
        }
        #grid {
            max-width: 100%;
            margin-top: 16px;
        }
        body.game-live #gridWrapper {
            width: 100%;
        }
        #recruiterPanel {
            max-width: 100%;
            margin: 0 8px;
            padding: 14px 16px;
        }
        #recruiterSummary {
            font-size: 14px;
        }
        #closeRecruiterBtn {
            font-size: 14px;
            padding: 8px 10px;
        }
        #messageOverlay .message-panel {
            padding: 18px;
        }
        #messageOverlay .message-panel p {
            font-size: 16px;
        }
        #messageOverlay .message-panel button {
            font-size: 15px;
        }
        #doorOverlay .door-panel {
            padding: 16px;
        }
        #doorOverlay .door-panel p {
            font-size: 16px;
        }
        body[data-grid-size="5"] #controls button {
            font-size: 15px;
            padding: 10px 14px;
            min-height: 50px;
        }
        body[data-grid-size="6"] #controls button {
            font-size: 14.5px;
            padding: 9px 12px;
            min-height: 46px;
        }
        body[data-grid-size="7"] #controls button {
            font-size: 14px;
            padding: 8px 11px;
            min-height: 44px;
        }
        body[data-grid-size="8"] #controls button {
            font-size: 13.5px;
            padding: 7px 10px;
            min-height: 40px;
        }
        body[data-grid-size="9"] #controls button {
            font-size: 12.5px;
            padding: 6px 8px;
            min-height: 36px;
        }
        body.compact-ui #controls button {
            min-height: 34px;
        }
        body[data-grid-size="5"] #restartBtn {
            font-size: 18px;
            padding: 12px 22px;
            min-height: 48px;
        }
        body[data-grid-size="6"] #restartBtn {
            font-size: 17px;
            padding: 11px 20px;
            min-height: 46px;
        }
        body[data-grid-size="7"] #restartBtn {
            font-size: 16px;
            padding: 10px 18px;
            min-height: 44px;
        }
        body[data-grid-size="8"] #restartBtn {
            font-size: 15px;
            padding: 10px 16px;
            min-height: 42px;
        }
        body[data-grid-size="9"] #restartBtn {
            font-size: 13px;
            padding: 9px 14px;
            min-height: 38px;
        }
    }

    @media (min-width: 768px) {
        #instructionsToggle {
            display: none;
        }
        body.game-live #playArea {
            flex-direction: row;
            align-items: flex-start;
        }
        body.game-live #instructions {
            text-align: left;
            margin: 0;
        }
        body.game-live #gridWrapper {
            display: flex;
            flex: 1;
        }
    }
</style>
</head>
<body>

<h1>Memory Grid Game</h1>

<div id="controls">
    <button id="startBtn" onclick="startGame()">Start Game</button>
    <button id="easyBtn" onclick="setDifficulty('easy')">Easy</button>
    <button id="hardBtn" onclick="setDifficulty('hard')">Hard (Hiring Style)</button>
    <button id="harderBtn" onclick="makeGridHarder()">Next Level</button>
</div>

<div id="levelMessage" role="status" aria-live="polite">Press Start Game to begin.</div>

<div id="stats">
    üî¢ Level: <span id="levelDisplay">1 / 5</span>  
    | ‚è± Time: <span id="timer">0</span>s  
    | üîÑ Resets: <span id="resets">0</span>  
    | ü¶∂ Moves: <span id="moves">0</span>  
    | üîë Key: <span id="keyStatus">No</span>
</div>

<div id="playArea">
<div id="instructions">
    <button id="instructionsToggle" type="button" aria-expanded="true" aria-controls="instructionsContent" onclick="toggleInstructionsAccordion()">
        <span>How to play</span>
        <span class="chevron" aria-hidden="true"></span>
    </button>
    <div class="instructions-content" id="instructionsContent">
        <strong>How to play:</strong>
        <ul>
            <li>Hit <strong>Start Game</strong> when you're ready; the timer begins once the board appears.</li>
            <li>Tap tiles to trace the hidden safe path from <strong>S</strong> to the door.</li>
            <li>The door stays locked until you uncover the hidden <strong>key</strong>.</li>
            <li>A wrong tile resets the board (hard mode hides your progress).</li>
            <li>Use Restart to start over or Next Level to skip ahead‚Äîonly wins count toward finishing all five levels.</li>
        </ul>
    </div>
</div>

    <div id="gridWrapper">
        <div id="grid"></div>
    </div>
</div>

<button id="restartBtn" onclick="restartGame()">Restart Game</button>

<div id="messageOverlay" aria-live="assertive">
    <div class="message-panel">
        <p id="overlayMessageText"></p>
        <button type="button" onclick="hideMessageOverlay()">Continue</button>
    </div>
</div>

<div id="doorOverlay" aria-live="assertive">
    <div class="door-panel">
        <p id="doorOverlayText"></p>
        <button type="button" onclick="hideDoorOverlay()">Continue</button>
    </div>
</div>

<div id="recruiterOverlay">
    <div id="recruiterPanel">
        <button class="close-icon" aria-label="Close insights" onclick="hideRecruiterInsights()">√ó</button>
        <h2>Recruiter View: Behavioural Insights</h2>
        <div id="recruiterTags"></div>
        <ul id="recruiterSummary"></ul>
        <button id="closeRecruiterBtn" onclick="hideRecruiterInsights()">Close</button>
    </div>
</div>

<script>
const LEVELS = [5, 6, 7, 8, 9];
const TOTAL_LEVELS = LEVELS.length;
let currentLevelIndex = 0;
let gridSize = LEVELS[currentLevelIndex];
let start = { r: 0, c: 0 };
let end = { r: gridSize - 1, c: gridSize - 1 };
let path = [];
let revealed = [];
let resets = 0;
let moves = 0;
let timer = 0;
let timerInterval = null;
let difficulty = "easy"; // default to easier mode
const MIN_START_END_DISTANCE = 4; // keep S and E apart for better gameplay
const GRID_GAP = 5;
const MOBILE_BREAKPOINT = 600;
let keyCell = null;
let hasKey = false;
let pendingResetTimeout = null;
let levelsWon = 0;
let gameActive = false;
let currentAttempt = 1;
let pendingLevelAction = null;
let isTransitioning = false;

const analytics = {
    sessionId: Date.now(),
    difficulty: null,
    levelId: null,
    moves: [],
    resets: [],
    wins: [],
    startedAt: null,
    endedAt: null,
    levelHistory: []
};

// Update difficulty UI
function updateDifficultyButtons() {
    document.getElementById("easyBtn").classList.toggle("active", difficulty === "easy");
    document.getElementById("hardBtn").classList.toggle("active", difficulty === "hard");
}

// Called from buttons
function setDifficulty(level) {
    if (isTransitioning) return;
    if (difficulty === level) return;
    difficulty = level;
    updateDifficultyButtons();
    if (!gameActive) {
        showMessage(`${level === "easy" ? "Easy" : "Hard"} mode selected. Press Start Game to begin.`);
        return;
    }
    initializeGameState();
}

// Initialize revealed grid
function initRevealed() {
    revealed = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
    revealed[start.r][start.c] = true; // Start always visible
    // End will be shown as E but not marked safe until clicked correctly
}

function updateLevelDisplay() {
    document.getElementById("levelDisplay").textContent = `${currentLevelIndex + 1} / ${TOTAL_LEVELS}`;
}

function updateKeyStatus() {
    document.getElementById("keyStatus").textContent = hasKey ? "Yes" : "No";
}

function showMessage(msg) {
    const messageEl = document.getElementById("levelMessage");
    messageEl.textContent = msg;
}


function showDoorOverlay(message) {
    const overlay = document.getElementById("doorOverlay");
    const text = document.getElementById("doorOverlayText");
    if (text) {
        text.textContent = message || "üö™ The door is locked! Grab the key first.";
    }
    if (overlay) {
        overlay.classList.add("active");
    }
}

function hideDoorOverlay() {
    const overlay = document.getElementById("doorOverlay");
    if (overlay) {
        overlay.classList.remove("active");
    }
}

function hideMessageOverlay() {
    const overlay = document.getElementById("messageOverlay");
    if (overlay) {
        overlay.classList.remove("active");
        const panel = overlay.querySelector(".message-panel");
        if (panel) {
            panel.innerHTML = `<p id="overlayMessageText"></p>
                <button type="button" onclick="hideMessageOverlay()">Continue</button>`;
        }
    }
}

function showStatsOverlay(title, lines, finalRun = false) {
    const overlay = document.getElementById("messageOverlay");
    if (!overlay) return;
    const panel = overlay.querySelector(".message-panel");
    if (!panel) return;
    panel.innerHTML = "";
    const heading = document.createElement("h3");
    heading.textContent = title;
    panel.appendChild(heading);
    const list = document.createElement("div");
    list.className = "stats-lines";
    lines.forEach(text => {
        const p = document.createElement("p");
        p.textContent = text;
        list.appendChild(p);
    });
    panel.appendChild(list);
    const button = document.createElement("button");
    button.textContent = finalRun ? "Restart Game" : "Continue";
    button.onclick = () => {
        hideMessageOverlay();
        if (finalRun) {
            restartGame(true);
        } else {
            applyPendingLevelAction();
        }
    };
    panel.appendChild(button);
    overlay.classList.add("active");
}

function updateLayoutState() {
    document.body.classList.toggle("game-live", gameActive);
}

function updateCompactUIState() {
    const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
    const compact = isMobile && gridSize >= 8;
    document.body.classList.toggle("compact-ui", compact);
    document.body.dataset.gridSize = gridSize;
}

function setInstructionsCollapsed(collapsed) {
    const instructions = document.getElementById("instructions");
    const toggle = document.getElementById("instructionsToggle");
    if (!instructions) return;
    instructions.classList.toggle("collapsed", collapsed);
    if (toggle) {
        toggle.setAttribute("aria-expanded", (!collapsed).toString());
    }
}

function toggleInstructionsAccordion() {
    if (window.innerWidth > MOBILE_BREAKPOINT) return;
    const instructions = document.getElementById("instructions");
    if (!instructions) return;
    const collapsed = instructions.classList.contains("collapsed");
    setInstructionsCollapsed(!collapsed);
}

function collapseInstructionsForMobile() {
    if (window.innerWidth <= MOBILE_BREAKPOINT) {
        setInstructionsCollapsed(true);
    }
}

function resetIdleUI(message = "Press Start Game to begin.") {
    stopTimer();
    cancelPendingReset();
    timer = 0;
    moves = 0;
    resets = 0;
    hasKey = false;
    keyCell = null;
    path = [];
    revealed = [];
    levelsWon = 0;
    document.getElementById("timer").textContent = timer;
    document.getElementById("moves").textContent = moves;
    document.getElementById("resets").textContent = resets;
    updateKeyStatus();
    updateLevelDisplay();
    showMessage(message);
    const collapseForMobile = window.innerWidth <= MOBILE_BREAKPOINT;
    setInstructionsCollapsed(collapseForMobile);
    const grid = document.getElementById("grid");
    if (grid) grid.innerHTML = "";
    hideRecruiterInsights(false);
    hideDoorOverlay();
    hideMessageOverlay();
}

function updateResponsiveCellSize() {
    const gridElement = document.getElementById("grid");
    if (!gridElement) return;
    const viewportWidth = window.innerWidth || 360;
    const horizontalPadding = viewportWidth <= 600 ? 32 : 80;
    const maxWidth = Math.min(viewportWidth - horizontalPadding, 520);
    const safeWidth = Math.max(220, maxWidth);
    const totalGap = (gridSize - 1) * GRID_GAP;
    let cellSize = Math.floor((safeWidth - totalGap) / gridSize);
    cellSize = Math.max(28, Math.min(64, cellSize));
    const gridWidth = cellSize * gridSize + totalGap;
    document.documentElement.style.setProperty("--cell-size", `${cellSize}px`);
    document.documentElement.style.setProperty("--grid-gap", `${GRID_GAP}px`);
    gridElement.style.width = `${gridWidth}px`;
    gridElement.style.maxWidth = "100%";
    updateCompactUIState();
}

function handleResponsiveResize() {
    updateResponsiveCellSize();
    if (window.innerWidth > MOBILE_BREAKPOINT) {
        setInstructionsCollapsed(false);
    }
    updateCompactUIState();
}

function resetAnalyticsForLevel() {
    analytics.difficulty = difficulty;
    analytics.levelId = `Level-${currentLevelIndex + 1}`;
    analytics.moves = [];
    analytics.resets = [];
    analytics.startedAt = performance.now();
    analytics.endedAt = null;
    currentAttempt = 1;
}

function logMoveEvent(event) {
    analytics.moves.push(event);
}

function logResetEvent(event) {
    analytics.resets.push(event);
}

function logWinEvent(event) {
    analytics.wins.push(event);
}

// Generate a random safe path
function generatePath() {
    let candidate;
    let guard = 0;
    do {
        candidate = buildPathCandidate();
        guard++;
    } while (!pathHasMultipleTurns(candidate) && guard < 50);
    return candidate;
}

function buildPathCandidate() {
    let r = start.r;
    let c = start.c;
    let p = [{ r, c }];

    while (r !== end.r || c !== end.c) {
        let choices = [];
        if (r < end.r) choices.push("down");
        if (c < end.c) choices.push("right");
        if (r > end.r) choices.push("up");
        if (c > end.c) choices.push("left");

        let move = choices[Math.floor(Math.random() * choices.length)];

        if (move === "down") r++;
        if (move === "right") c++;
        if (move === "up") r--;
        if (move === "left") c--;

        p.push({ r, c });
    }
    return p;
}

function pathHasMultipleTurns(path) {
    if (!path || path.length < 4) return false;
    let prevDir = null;
    let turns = 0;
    for (let i = 1; i < path.length; i++) {
        const dir = directionBetween(path[i - 1], path[i]);
        if (!dir) continue;
        if (prevDir && dir !== prevDir) {
            turns++;
            if (turns >= 2) return true;
        }
        prevDir = dir;
    }
    return false;
}

function directionBetween(a, b) {
    if (b.r > a.r) return "down";
    if (b.r < a.r) return "up";
    if (b.c > a.c) return "right";
    if (b.c < a.c) return "left";
    return null;
}

function placeKey() {
    if (path.length <= 2) {
        keyCell = null;
        return;
    }
    const middleCells = path.slice(1, path.length - 1);
    let candidates = middleCells.filter(cell => {
        const nearStart = manhattanDistance(cell, start) <= 1;
        const nearEnd = manhattanDistance(cell, end) <= 1;
        return !(nearStart || nearEnd);
    });
    if (!candidates.length) {
        candidates = middleCells;
    }
    keyCell = candidates[Math.floor(Math.random() * candidates.length)];
}

// Build the grid UI
function createGrid() {
    const grid = document.getElementById("grid");
    updateResponsiveCellSize();
    if (!gameActive) {
        grid.innerHTML = "";
        return;
    }
    grid.innerHTML = "";
    grid.style.gridTemplateColumns = `repeat(${gridSize}, var(--cell-size))`;
    grid.style.gridTemplateRows = `repeat(${gridSize}, var(--cell-size))`;

    for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
            let div = document.createElement("div");
            div.classList.add("cell");

            if (r === start.r && c === start.c) {
                div.textContent = "S";
                div.classList.add("start");
            } 
            else if (r === end.r && c === end.c) {
                div.textContent = "D";
                div.classList.add("door");
            }
            else if (keyCell && r === keyCell.r && c === keyCell.c) {
                if (revealed[r][c]) {
                    div.classList.add("key");
                    div.textContent = "K";
                } else {
                    div.textContent = "?";
                }
            }
            else if (revealed[r][c]) {
                // EASY mode: keep showing discovered safes
                if (difficulty === "easy") {
                    div.classList.add("safe");
                    div.textContent = "";
                } else {
                    // HARD mode: do not show previous safes, keep them hidden
                    div.textContent = "?";
                }
            } 
            else {
                div.textContent = "?";
            }

            div.onclick = () => cellClicked(r, c, div);
            grid.appendChild(div);
        }
    }
}

// Handle clicks
function cellClicked(r, c, cell) {
    if (!gameActive) {
        showMessage("Press Start Game to begin!");
        return;
    }
    moves++;
    document.getElementById("moves").textContent = moves;

    const isStartCell = (r === start.r && c === start.c);
    const isEndCell = (r === end.r && c === end.c);
    let isSafe = path.some(p => p.r === r && p.c === c);

    logMoveEvent({
        time: performance.now(),
        row: r,
        col: c,
        result: isSafe ? "safe" : "wall",
        isStart: isStartCell,
        isEnd: isEndCell,
        moveNumber: moves,
        attemptNumber: currentAttempt
    });

    if (isStartCell) return;

    if (!isSafe) {
        cell.classList.add("wall");
        scheduleResetAfterMistake();
        return;
    }

    // Correct (safe) tile
    revealed[r][c] = true;

    // Always show it for the current attempt
    cell.classList.add("safe");
    cell.textContent = "";

    if (keyCell && r === keyCell.r && c === keyCell.c && !hasKey) {
        hasKey = true;
        updateKeyStatus();
        showDoorOverlay("üîë Key collected! Find the door.");
        showMessage("Key collected! Find the door.");
        cell.classList.remove("safe");
        cell.classList.add("key");
        cell.textContent = "K";
        return;
    }

    if (r === end.r && c === end.c) {
        if (!hasKey) {
            showDoorOverlay("üö™ The door is locked! Grab the key first.");
            showMessage("The door is locked! Grab the key first.");
            return;
        }
        stopTimer();
        levelComplete();
    }
}

// When user hits a wall
function resetAfterMistake() {
    if (!gameActive) return;
    const movesBeforeReset = moves;
    resets++;
    document.getElementById("resets").textContent = resets;
    moves = 0;
    document.getElementById("moves").textContent = moves;

    hasKey = false;
    updateKeyStatus();

    logResetEvent({
        time: performance.now(),
        attemptNumber: currentAttempt,
        movesBeforeReset
    });
    currentAttempt++;

    if (difficulty === "easy") {
        // Keep known safes visible
        createGrid();
    } else {
        // HARD: forget all discovered safes visually & logically
        initRevealed();
        createGrid();
    }
    showMessage("Ouch! Try again from the start.");
}

function scheduleResetAfterMistake() {
    cancelPendingReset();
    pendingResetTimeout = setTimeout(() => {
        pendingResetTimeout = null;
        resetAfterMistake();
    }, 400);
}

function cancelPendingReset() {
    if (pendingResetTimeout !== null) {
        clearTimeout(pendingResetTimeout);
        pendingResetTimeout = null;
    }
}

// Restart everything
function initializeGameState() {
    if (!gameActive || isTransitioning) return;
    isTransitioning = true;
    try {
        cancelPendingReset();
        hideRecruiterInsights(false);
        const levelSize = LEVELS[currentLevelIndex];
        gridSize = levelSize;
        resets = 0;
        moves = 0;
        timer = 0;
        hasKey = false;
        document.getElementById("resets").textContent = resets;
        document.getElementById("moves").textContent = moves;
        document.getElementById("timer").textContent = timer;
        updateKeyStatus();
        updateLevelDisplay();
        showMessage("Collect the key before heading to the door.");

        resetAnalyticsForLevel();

        startTimer();

        randomizeStartEnd();

        initRevealed();
        path = generatePath();
        placeKey();
        createGrid();
        if (window.innerWidth <= MOBILE_BREAKPOINT) {
            setInstructionsCollapsed(true);
        }
    } finally {
        isTransitioning = false;
    }
}

function restartGame(forceStart = false) {
    if (isTransitioning) return;
    pendingLevelAction = null;
    currentLevelIndex = 0;
    levelsWon = 0;
    if (!forceStart && !gameActive) {
        resetIdleUI();
        return;
    }
    if (forceStart) {
        if (!gameActive) {
            gameActive = true;
            updateLayoutState();
        }
        initializeGameState();
    } else {
        gameActive = false;
        updateLayoutState();
        resetIdleUI("Game reset. Press Start Game to begin again.");
    }
}

function startGame() {
    if (isTransitioning) return;
    restartGame(true);
    collapseInstructionsForMobile();
}

function makeGridHarder() {
    if (isTransitioning) return;
    if (!gameActive) {
        showMessage("Start the game before skipping levels.");
        return;
    }
    if (currentLevelIndex < TOTAL_LEVELS - 1) {
        currentLevelIndex++;
        initializeGameState();
    } else {
        showMessage("You're already on the final level!");
    }
}

// Timer
function startTimer() {
    stopTimer();
    timerInterval = setInterval(() => {
        timer++;
        document.getElementById("timer").textContent = timer;
    }, 1000);
}

function stopTimer() {
    if (timerInterval !== null) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
}

function randomCell() {
    return {
        r: Math.floor(Math.random() * gridSize),
        c: Math.floor(Math.random() * gridSize)
    };
}

function distanceBetween(a, b) {
    const dr = a.r - b.r;
    const dc = a.c - b.c;
    return Math.hypot(dr, dc);
}

function manhattanDistance(a, b) {
    return Math.abs(a.r - b.r) + Math.abs(a.c - b.c);
}

function randomizeStartEnd() {
    // Generate unique random positions with sufficient spacing
    start = randomCell();

    do {
        end = randomCell();
    } while (shouldRepositionStartEnd(start, end));
}   

function shouldRepositionStartEnd(a, b) {
    if (a.r === b.r && a.c === b.c) return true;
    const rowGap = Math.abs(a.r - b.r);
    const colGap = Math.abs(a.c - b.c);
    const tooClose = distanceBetween(a, b) < MIN_START_END_DISTANCE;
    const insufficientRowGap = rowGap < 2;
    const insufficientColGap = colGap < 2;
    const straightLine = (a.r === b.r) || (a.c === b.c);
    return tooClose || insufficientRowGap || insufficientColGap || straightLine;
}

function levelComplete() {
    const levelNumber = currentLevelIndex + 1;
    levelsWon = Math.min(levelsWon + 1, TOTAL_LEVELS);
    analytics.endedAt = performance.now();
    hideDoorOverlay();

    const winSnapshot = {
        time: analytics.endedAt,
        levelId: analytics.levelId,
        totalTime: timer,
        totalMoves: analytics.moves.length,
        totalResets: analytics.resets.length,
        attemptsUsed: currentAttempt,
        difficulty: analytics.difficulty
    };
    logWinEvent(winSnapshot);

    const insights = computeRecruiterInsights();
    analytics.levelHistory.push({
        levelId: analytics.levelId,
        insights
    });
    showRecruiterInsights(insights);

    const stats = [
        `Time: ${timer}s`,
        `Resets: ${resets}`,
        `Moves: ${moves}`,
        `Levels completed: ${levelsWon}/${TOTAL_LEVELS}`
    ];

    if (levelsWon >= TOTAL_LEVELS) {
        showStatsOverlay("üèÜ All five levels complete!", stats, true);
        pendingLevelAction = null;
        return;
    }

    if (currentLevelIndex < TOTAL_LEVELS - 1) {
        showStatsOverlay(`üéâ Level ${levelNumber} cleared!`, stats);
        pendingLevelAction = "advance";
    } else {
        const remaining = TOTAL_LEVELS - levelsWon;
        stats.push(`Still ${remaining} level${remaining === 1 ? "" : "s"} to finish all five.`);
        showStatsOverlay("Final level cleared!", stats);
        pendingLevelAction = "restartAuto";
    }
}

function computeRecruiterInsights() {
    const moves = analytics.moves || [];
    const resetsLogged = analytics.resets || [];
    if (!moves.length) {
        return {
            metrics: {
                totalMoves: 0,
                totalResets: resetsLogged.length,
                attemptsUsed: currentAttempt,
                adjacentMoveRatio: 0,
                repeatedErrorCount: 0,
                safeRatio: 0,
                wallRatio: 0,
                earlyErrors: 0,
                lateErrors: 0,
                errorsTrend: "flat"
            },
            labels: {
                explorationStrategy: "No Data",
                learningAgility: "No Data",
                workingMemory: "No Data",
                timePressure: "No Data",
                riskAppetite: "No Data"
            },
            summaryLines: ["Not enough moves were recorded to derive behavioural insights."]
        };
    }

    const totalMoves = moves.length;
    const safeMoves = moves.filter(m => m.result === "safe").length;
    const wallMoves = totalMoves - safeMoves;

    let adjacentMoves = 0;
    for (let i = 1; i < moves.length; i++) {
        const prev = moves[i - 1];
        const curr = moves[i];
        if (Math.abs(prev.row - curr.row) + Math.abs(prev.col - curr.col) === 1) {
            adjacentMoves++;
        }
    }
    const adjacentMoveRatio = moves.length > 1 ? adjacentMoves / (moves.length - 1) : 1;

    const seenWallCells = new Set();
    let repeatedErrorCount = 0;
    moves.forEach(move => {
        if (move.result === "wall") {
            const key = `${move.row},${move.col}`;
            if (seenWallCells.has(key)) {
                repeatedErrorCount++;
            } else {
                seenWallCells.add(key);
            }
        }
    });

    const movesByAttempt = {};
    moves.forEach(move => {
        if (!movesByAttempt[move.attemptNumber]) {
            movesByAttempt[move.attemptNumber] = [];
        }
        movesByAttempt[move.attemptNumber].push(move);
    });

    const attemptNumbers = Object.keys(movesByAttempt).map(Number).sort((a, b) => a - b);
    const attemptStats = attemptNumbers.map(num => {
        const attemptMoves = movesByAttempt[num].sort((a, b) => a.moveNumber - b.moveNumber);
        const walls = attemptMoves.filter(m => m.result === "wall").length;
        const earlyLimit = Math.max(1, Math.ceil(attemptMoves.length * 0.4));
        let earlyErrors = 0;
        let lateErrors = 0;
        attemptMoves.forEach(move => {
            if (move.result === "wall") {
                if (move.moveNumber <= earlyLimit) {
                    earlyErrors++;
                } else {
                    lateErrors++;
                }
            }
        });

        return {
            attemptNumber: num,
            moves: attemptMoves.length,
            walls,
            earlyErrors,
            lateErrors
        };
    });

    const errorsTrend = determineTrend(attemptStats.map(a => a.walls));
    const moveTrend = determineTrend(attemptStats.map(a => a.moves));
    const totalEarlyErrors = attemptStats.reduce((sum, stat) => sum + stat.earlyErrors, 0);
    const totalLateErrors = attemptStats.reduce((sum, stat) => sum + stat.lateErrors, 0);

    const firstMoveTime = moves[0].time;
    const lastMoveTime = moves[moves.length - 1].time;
    const timeRange = lastMoveTime - firstMoveTime;
    const timePerMoveAvg = moves.length > 1 ? timeRange / (moves.length - 1) : 0;
    const firstSegmentCount = Math.max(1, Math.floor(moves.length * 0.3));
    const lastSegmentCount = Math.max(1, Math.floor(moves.length * 0.3));
    const firstSegmentAvg = computeSegmentPace(moves.slice(0, firstSegmentCount));
    const lastSegmentAvg = computeSegmentPace(moves.slice(moves.length - lastSegmentCount));
    const timePressureDelta = lastSegmentAvg - firstSegmentAvg;

    const safeRatio = safeMoves / totalMoves;
    const wallRatio = wallMoves / totalMoves;

    let explorationStrategy = "Mixed";
    if (adjacentMoveRatio >= 0.75 && repeatedErrorCount <= 1) {
        explorationStrategy = "Systematic";
    } else if (adjacentMoveRatio <= 0.5 && repeatedErrorCount >= 3) {
        explorationStrategy = "Random";
    }

    let learningAgility = "Moderate";
    if (errorsTrend === "improving" || moveTrend === "improving") {
        learningAgility = "High";
    } else if (errorsTrend === "worsening") {
        learningAgility = "Low";
    }

    let workingMemory = "Average";
    if (repeatedErrorCount <= 1) {
        workingMemory = "Strong";
    } else if (repeatedErrorCount >= 4) {
        workingMemory = "Struggles";
    }

    let timePressure = "Calm";
    if (timePressureDelta > 400) {
        timePressure = "Highly Affected";
    } else if (timePressureDelta > 150) {
        timePressure = "Somewhat Affected";
    }

    let riskAppetite = "Balanced";
    if (wallRatio <= 0.12) {
        riskAppetite = "Over-cautious";
    } else if (wallRatio >= 0.4) {
        riskAppetite = "Over-risking";
    }

    const metrics = {
        totalMoves,
        safeMoves,
        wallMoves,
        totalResets: resetsLogged.length,
        attemptsUsed: currentAttempt,
        adjacentMoveRatio,
        repeatedErrorCount,
        errorsTrend,
        moveTrend,
        earlyErrors: totalEarlyErrors,
        lateErrors: totalLateErrors,
        timePerMoveAvg,
        firstSegmentAvg,
        lastSegmentAvg,
        timePressureDelta,
        safeRatio,
        wallRatio,
        durationMs: analytics.endedAt && analytics.startedAt ? analytics.endedAt - analytics.startedAt : timeRange
    };

    const labels = {
        explorationStrategy,
        learningAgility,
        workingMemory,
        timePressure,
        riskAppetite
    };

    const summaryLines = buildRecruiterSummary({ metrics, labels });

    return { metrics, labels, summaryLines };
}

function determineTrend(values) {
    if (!values.length || values.every(v => v === 0)) return "flat";
    if (values.length === 1) return "flat";
    const first = values[0];
    const last = values[values.length - 1];
    if (first === 0 && last === 0) return "flat";
    if (first === 0 && last > 0) return "worsening";
    const ratio = last / (first || 1);
    if (ratio <= 0.7 || last < first) return "improving";
    if (ratio >= 1.3 && last > first) return "worsening";
    return "flat";
}

function computeSegmentPace(segmentMoves) {
    if (!segmentMoves.length || segmentMoves.length === 1) return 0;
    const duration = segmentMoves[segmentMoves.length - 1].time - segmentMoves[0].time;
    return duration / (segmentMoves.length - 1);
}

function buildRecruiterSummary(insights) {
    const { metrics, labels } = insights;
    const lines = [];
    const adjacentPercent = Math.round((metrics.adjacentMoveRatio || 0) * 100);
    lines.push(`Exploration style: ${labels.explorationStrategy} (${adjacentPercent}% adjacent moves, ${metrics.repeatedErrorCount} repeated wall clicks).`);

    const totalErrors = metrics.earlyErrors + metrics.lateErrors;
    if (totalErrors > 0) {
        const earlyShare = Math.round((metrics.earlyErrors / totalErrors) * 100);
        const clusteringText = metrics.earlyErrors >= metrics.lateErrors
            ? `${earlyShare}% of errors happened early before stabilising.`
            : `Late-run errors (${100 - earlyShare}% of them) indicate fading focus.`;
        lines.push(`Learning curve: ${labels.learningAgility}. ${clusteringText}`);
    } else {
        lines.push(`Learning curve: ${labels.learningAgility}. No wall hits after the initial exploration.`);
    }

    lines.push(`Working memory & recall: ${labels.workingMemory}, with ${metrics.repeatedErrorCount} repeated mistakes out of ${totalErrors || 0} errors.`);

    const paceFirst = Math.round(metrics.firstSegmentAvg || 0);
    const paceLast = Math.round(metrics.lastSegmentAvg || 0);
    lines.push(`Time pressure: ${labels.timePressure} (avg pace ${Math.round(metrics.timePerMoveAvg || 0)}ms/move, shifted from ${paceFirst}ms early to ${paceLast}ms late).`);

    const safePercent = Math.round((metrics.safeRatio || 0) * 100);
    const wallPercent = Math.round((metrics.wallRatio || 0) * 100);
    lines.push(`Risk appetite: ${labels.riskAppetite} (${safePercent}% safe vs ${wallPercent}% wall clicks across ${metrics.attemptsUsed} attempt${metrics.attemptsUsed === 1 ? "" : "s"}).`);

    return lines;
}

function showRecruiterInsights(insights) {
    if (!insights) return;
    const overlay = document.getElementById("recruiterOverlay");
    if (!overlay) return;
    const tags = document.getElementById("recruiterTags");
    const summaryEl = document.getElementById("recruiterSummary");
    tags.innerHTML = "";
    summaryEl.innerHTML = "";

    const labelMap = {
        "Exploration": insights.labels.explorationStrategy,
        "Learning": insights.labels.learningAgility,
        "Memory": insights.labels.workingMemory,
        "Time Pressure": insights.labels.timePressure,
        "Risk": insights.labels.riskAppetite
    };

    Object.entries(labelMap).forEach(([key, value]) => {
        const span = document.createElement("span");
        span.className = "recruiter-tag";
        span.textContent = `${key}: ${value}`;
        tags.appendChild(span);
    });

    insights.summaryLines.forEach(line => {
        const li = document.createElement("li");
        li.textContent = line;
        summaryEl.appendChild(li);
    });

    overlay.classList.add("active");
}

function hideRecruiterInsights(triggerAction = true) {
    const overlay = document.getElementById("recruiterOverlay");
    if (overlay) {
        overlay.classList.remove("active");
    }
    if (triggerAction) {
        applyPendingLevelAction();
    } else if (currentLevelIndex >= TOTAL_LEVELS - 1) {
        restartGame(false);
    }
}

function applyPendingLevelAction() {
    if (!pendingLevelAction) return;
    if (isTransitioning) {
        setTimeout(applyPendingLevelAction, 100);
        return;
    }
    const action = pendingLevelAction;
    pendingLevelAction = null;
    if (action === "advance") {
        currentLevelIndex++;
        initializeGameState();
    } else if (action === "restartAuto") {
        restartGame(true);
    }
}

// Init on load
updateDifficultyButtons();
handleResponsiveResize();
window.addEventListener("resize", handleResponsiveResize);
updateLayoutState();
resetIdleUI();

</script>

</body>
</html>
